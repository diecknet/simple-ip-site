import { getAssetFromKV, mapRequestToAsset } from '@cloudflare/kv-asset-handler'

/**
 * The DEBUG flag will do two things that help during development:
 * 1. we will skip caching on the edge, which makes it easier to
 *    debug.
 * 2. we will return an error message on exception in your Response rather
 *    than the default 404.html page.
 */
const DEBUG = false

addEventListener('fetch', event => {
  try {
    event.respondWith(handleEvent(event))
  } catch (e) {
    if (DEBUG) {
      return event.respondWith(
        new Response(e.message || e.toString(), {
          status: 500,
        }),
      )
    }
    event.respondWith(new Response('Internal Error', { status: 500 }))
  }
})

async function handleEvent(event) {
  const url = new URL(event.request.url)
  let options = {}
  let request = event.request;
  console.log("URL LOG: "+url.pathname);
  console.log("CF LOG: ");
  console.log(request.cf);
  
  

  switch(url.pathname) {
    case "/api":
      /* */
      return getClientIPInfo(event);
      break;
      default:
        try {
          if (DEBUG) {
            // customize caching
            options.cacheControl = {
              bypassCache: true,
            }
          }
      
          const page = await getAssetFromKV(event, options)
      
          // allow headers to be altered
          const response = new Response(page.body, page)
      
          response.headers.set('X-XSS-Protection', '1; mode=block')
          response.headers.set('X-Content-Type-Options', 'nosniff')
          response.headers.set('X-Frame-Options', 'DENY')
          response.headers.set('Referrer-Policy', 'unsafe-url')
          response.headers.set('Feature-Policy', 'none')
      
          return response
      
        } catch (e) {
          // if an error is thrown try to serve the asset at 404.html
          if (!DEBUG) {
            try {
              let notFoundResponse = await getAssetFromKV(event, {
                mapRequestToAsset: req => new Request(`${new URL(req.url).origin}/404.html`, req),
              })
      
              return new Response(notFoundResponse.body, { ...notFoundResponse, status: 404 })
            } catch (e) {}
          }
      
          return new Response(e.message || e.toString(), { status: 500 })
        }
  
  }
}

function getClientIPInfo(request) {
  /* get clientdata from cloudflare */
  console.log("executed getClientIPInfo");
  console.log("request=");
  console.log(request);
  const clientIPInfo = {
    /* get client ip address by Cloudflare header "CF-Connecting-IP" */
    ip: request.headers.get("CF-Connecting-IP"),
    /* get country of client ip address by Cloudflare header "CF-IPCountry" */
    country: request.headers.get("CF-IPCountry"),
    /* the ||-comparison is to prevent errors in the workers quick edit mode */
    city: (request.cf || {}).city
  }
  return clientIPInfo
}

/**
 * Responds with the local time.
 * @param {Request} request
 * @returns {Response}
 */
function respondClientIPInfo(request) {
  const { headers, cf } = request

  /* allowedOrigin contains our default allowed 'Origin' Header of the requesting client */
  var allowedOrigin="https://ip.diecknet.de";
  
  /* check if Origin header was provided by client */
  if(headers.get('Origin')) {
    /*  if the HTTP Origin Header ends with one of our own Domains, put the value into 'allowedOrigin'
        so we can return that value later on as 'access-control-allow-origin' */
    if(
      headers.get('Origin').endsWith(".cmd-lvcw.pages.dev") ||
      headers.get('Origin').endsWith(".di1.workers.dev")
    ){
      allowedOrigin = headers.get('Origin');
    }
  } // no else{}, because we already defined 'allowedOrigin' before
     

  /* call getClientIPInfo() to gather client IP data */
  const clientIPInfo = getClientIPInfo(request)

  const jsonresponse = JSON.stringify(clientIPInfo);
  return new Response(jsonresponse, {
    status: 200,
    headers: {
      'Content-Type': 'application/json;charset=UTF-8',
      'Access-Control-Allow-Origin': allowedOrigin
    }
  })
}